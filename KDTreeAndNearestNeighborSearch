function New-TSAGVKDTree {
    <#
        .SYNOPSIS
        Builds a K-dimensional tree from a list of objects.

        .DESCRIPTION
        Builds a K-dimensional tree from a list of objects.

        InputObject should be an array with these properties:
            * The IDPropertyName property should be a unique identifier for the object, if you specify IDPropertyName.
            * Each value in the Dimensions array should be a property of the object.

        The result will be a K-D tree with the following properties on each node:
            * Axis:      The name of the dimension used to split the tree at this node.
            * LeftSide:  The left side of the tree.
            * RightSide: The right side of the tree.
            * Payload:   The original object at this node.  The name of this property can be changed with PayloadPropertyName.
            * ID:        The ID of the object at this node.  The name of this property can be changed with IDPropertyName.

        .PARAMETER InputObject
        The objects to build the tree from.

        .PARAMETER IDPropertyName
        The name of the property that contains the unique identifier for each object.

        .PARAMETER PayloadPropertyName
        The name of the property to use on the output for storing the original object at each node.

        .PARAMETER Dimensions
        The names of the properties to use for each dimension.

        .EXAMPLE
        PS> $Params = @{
            'InputObject' = @(
                [PSCustomObject]@{
                    'ID'        = 'A'
                    'Latitude'  = 1
                    'Longitude' = 1
                }
                [PSCustomObject]@{
                    'ID'        = 'B'
                    'Latitude'  = 2
                    'Longitude' = 2
                }
                [PSCustomObject]@{
                    'ID'        = 'C'
                    'Latitude'  = 3
                    'Longitude' = 3
                }
            )
            'IDPropertyName'      = 'ID'
            'PayloadPropertyName' = 'Payload'
            'Dimensions'          = @('Latitude', 'Longitude')
        }
        PS> New-TSAGVKDTree @Params | ConvertTo-Json -Depth 20

        {
            "Axis":"Latitude",
            "LeftSide":[{
                "Axis":"Longitude",
                "LeftSide":null,
                "RightSide":null,
                "Payload":{
                    "ID":"A",
                    "Latitude":1,
                    "Longitude":1
                },
                "Longitude":1,
                "Latitude":1,
                "ID":"A"
            }],
            "RightSide":[{
                "Axis":"Longitude","LeftSide":null,"RightSide":null,
                "Payload":{
                    "ID":"C",
                    "Latitude":3,
                    "Longitude":3
                },
                "Longitude":3,
                "Latitude":3,
                "ID":"C"
            }],
            "Payload":{
                "ID":"B",
                "Latitude":2,
                "Longitude":2
            },
            "Latitude":2,
            "Longitude":2,
            "ID":"B"
        }

        .NOTES
        ===========================================================================
        Created with:   Visual Studio Code
        Created on:     11/28/2023
        Created by:     Sean Sauve
        Organization:   The Salvation Army USS
        Filename:       New-TSAGVKDTree.ps1
        ===========================================================================
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][PSCustomObject[]]$InputObject,
        [string]$IDPropertyName,
        [string]$PayloadPropertyName = 'Payload',
        [Parameter(Mandatory)]$Dimensions = @('Latitude', 'Longitude')
    )
    $NewDimensions = $Dimensions[1..($Dimensions.Count - 1) + 0] #Move first to last
    $RecursiveParams = @{
        'PayloadPropertyName' = $PayloadPropertyName
        'Dimensions'          = $NewDimensions
    }
    if ($PSBoundParameters.ContainsKey('IDPropertyName')) {
        $RecursiveParams['IDPropertyName'] = $IDPropertyName
    }
    $Count = $InputObject.Count
    $Median = [math]::Floor($Count / 2)
    $DebugOutput = "Count: $Count; Median: $Median"
    $InputObject = $InputObject | Sort-Object -Property $Dimensions[0]
    $HasLeft = $Median -gt 0
    $LeftObjects = $null
    if ($HasLeft) {
        $LeftObjects = $InputObject[0..($Median - 1)]
        $DebugOutput += "; Left: 0..$($Median - 1); LeftObjects: $($LeftObjects.$IDPropertyName -join ', ')"
    }
    $HasRight = $Count - $Median - 1 -gt 0
    $RightObjects = $null
    if ($HasRight) {
        $RightObjects = $InputObject[($Median + 1)..($Count - 1)]
        $DebugOutput += "; Right: $($Median + 1)..$($Count - 1); RightObjects: $($RightObjects.$IDPropertyName -join ', ')"
    }
    Write-Debug $DebugOutput
    $Left = $null
    if ($HasLeft) {
        $Left = @(New-TSAGVKDTree -InputObject $LeftObjects @RecursiveParams)
    }
    $Right = $null
    if ($HasRight) {
        $Right = @(New-TSAGVKDTree -InputObject $RightObjects @RecursiveParams)
    }
    $MedianObject = $InputObject[$Median]
    $Output = [PSCustomObject]@{
        'Axis'               = $Dimensions[0]
        $PayloadPropertyName = $MedianObject
        'LeftSide'           = $Left
        'RightSide'          = $Right
    }
    foreach ($Property in $Dimensions) {
        $Output | Add-Member -NotePropertyName $Property -NotePropertyValue $MedianObject.$Property -Force
    }
    if ($PSBoundParameters.ContainsKey('IDPropertyName')) {
        $Output | Add-Member -NotePropertyName $IDPropertyName -NotePropertyValue $MedianObject.$IDPropertyName -Force
    }
    $Output
}
